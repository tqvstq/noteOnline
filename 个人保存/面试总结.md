# 面试总结

## 并发编程与多线程
java并发编程三大特性：`原子性`,`可见性`,`有序性`;
- 原子性:一个或者多个操作作为一个整体,执行过程中不可分割
- 可见性:多个线程访问同一个共享变量时,一个线程修改后,其他线程能够立刻知道
- 有序性:按照编写的代码顺序执行,不会进行优化排序
### volatile详解
volatile可以保证可见性和有序性,不能保证原子性,可以用于只有一个线程进行的修改操作的加锁,底层实现主要是通过内存屏障实现的,代码前面多出lock前缀(使用场景:1.共享状态的标识2:单例模式的双重检测锁)
内存屏障作用
1.重排序时不能把后面的指令重排序到内存屏障之前的位置
2.本CPU的Cache写入内存 
3.写入动作也会引起别的CPU或者别的内核Cache失效

### JMM(Java内存模型)
Java内存模型是一种抽象概念并不真实存在,JMM关于同步规定1.线程解锁前.必须讲共享变量的值刷新回主内存2.线程加锁前必须读取主内存的值到自己的工作内存3.加锁解锁是同一把锁

### ThreadLocal(本地线程)
ThreadLocal提供线程内部的局部变量，在本线程内随时随地可取，隔离其他线程,使用后记得清理防止线程池时数据混乱

### 单例模式实现
1、饿汉式(线程安全，调用效率高，但是不能延时加载)：
```java
public class ImageLoader{ 
     private static ImageLoader instance = new ImageLoader; 
     private ImageLoader(){} 
     public static ImageLoader getInstance(){  
          return instance;  
      } 
}
```
2、懒汉式(线程不安全，调用效率不高，但是能延时加载)：
```java
public class SingletonDemo2 {
     
    //类初始化时，不初始化这个对象(延时加载，真正用的时候再创建)
    private static SingletonDemo2 instance;
     
    //构造器私有化
    private SingletonDemo2(){}
     
    //方法同步，调用效率低
    public static synchronized SingletonDemo2 getInstance(){
        if(instance==null){
            instance=new SingletonDemo2();
        }
        return instance;
    }
}
```
2、Double CheckLock实现单例：
```java
// 指令重排序可能导致异常  加上 volatile
public class SingletonDemo5 {
        private volatile static SingletonDemo5 SingletonDemo5;
 
         private SingletonDemo5() {
        }
  
       public static SingletonDemo5 newInstance() {
             if (SingletonDemo5 == null) {
                synchronized (SingletonDemo5.class) {
                     if (SingletonDemo5 == null) {
                        // 分为三步 1.分配内存空间  2.初始化对象  3.将实列指向分配地址   2和3不存在依赖关系 多线程可能存在指令重新排序问题
                        SingletonDemo5 = new SingletonDemo5();
                    }
                }
             }
            return SingletonDemo5;
         }
     }
```
4、静态内部类实现模式（线程安全，调用效率高，可以延时加载）：
```java
public class SingletonDemo3 {
        private static class SingletonClassInstance {
            private static final SingletonDemo3 instance = new SingletonDemo3();
        }

        private SingletonDemo3() {
        }

        public static SingletonDemo3 getInstance() {
            return SingletonClassInstance.instance;
        }
    }
```
5、枚举类（线程安全，调用效率高，不能延时加载，可以天然的防止反射和反序列化调用）：
```java
public enum SingletonDemo4 {      
     //枚举元素本身就是单例
     INSTANCE;
     //添加自己需要的操作
     public void singletonOperation(){     
     }
}
```

### CAS(全称Compare And Swap比较并交换)
CAS有三个操作数，内存值V，旧的预期值E，要修改的新值N。当且仅当预期值E和内存值V相同时，将内存值V修改为N，否则什么都不做。
主要是基于Unsafe类所有方法都是native调用系统底层资源,(没公开源码)在jdk rt包sun\misc 下  主要是当前对象  当前对象内存地址  然后比较进行操作
JVM会帮我们实现汇编指令,基于硬件功能的系统原语

常用实现:JUC包下的原子类

缺点:1.线程多有些可能长期自旋带来CPU开销  2.只能保证一个变量原子操作  3.可能导致ABA问题

### ABA问题
CAS 比较并交换(只在意初始值和最后比较时候的值) 假设初始值为A 进入比较并交换 ,期间A被别的线程改成B并通知.然后又被别的线程改回A 此时初始线程获得A已经变更过 但是无法是识别出改动

解决办法:使用带时间戳(版本号)的原子引用 使用AtomicStampedReference类

### 原子引用
使用JUC包下AtomicReference类将对象实现原子操作

### 集合并发修改异常(java.util.ConcurrentModificationException)
ArrayList 初始不指定长度时为创建一个空的数组,当调用add方法时候的初始化为10

导致原因:



解决办法: 
1. 使用Vectot类
2. 使用Conllections类可以构造出线程安全的List   Conllections.synchronizedList(new ArrayList<>());
>
3. 使用JUC包下下CopyOnWriteArrayList
>




## 计算机网络面试知识


## 数据库

## Redis

## Linux

## JVM

## GC



## 常用类库

## Spring

## SpringBoot

## Nginx

## 工作经验解决问题流程
1. 故障现象
2. 导致原因
3. 解决方案
4. 优化建议